{
  parserClass="de.joachimsohn.language.parser.CDSParser"
  //parserUtilClass="de.joachimsohn.language.parser.CDSParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CDS"
  psiImplClassSuffix="Impl"
  psiPackage="de.joachimsohn.language.psi"
  psiImplPackage="de.joachimsohn.language.psi.impl"

  elementTypeHolderClass="de.joachimsohn.language.psi.CDSTypes"
  elementTypeClass="de.joachimsohn.language.psi.CDSElementType"
  tokenTypeClass="de.joachimsohn.language.psi.CDSTokenType"

  tokens = [
        LINE_COMMENT = 'regexp://.+'
        BLOCK_COMMENT = 'regexp:/\*.*\*/'
        //TODO: DOC_COMMENT missing https://cap.cloud.sap/docs/cds/cdl#doc-comment
        SPACE = 'regexp:\s+'
        NUMBER = 'regexp:\d+(\.\d*)?'
        STRING = 'regexp:[a-zA-Z]+'
  ]
}
root ::= namespace_? import_* body_*
namespace_ ::= namespace path';'

import_ ::= using '{' identifier (',' identifier)* '}' from hyphen_string';' //TODO: improve to match https://cap.cloud.sap/docs/cds/cdl#imports

private body_ ::= type_declaration | item_ | BLOCK_COMMENT | LINE_COMMENT

private type_declaration ::= "type" identifier ':' type_
private type_ ::= dataType enum '{' ( identifier';')+ '};'

item_ ::= ( service_ | entity_)
private entity_ ::= annotation* "define"? "entity" identifier (':' identifier)? '{' field_* '}'
private field_ ::= key? identifier ':' (dataType | relation_) required_? ';'
private relation_ ::= (Association to | Composition of) many? identifier required_? (on expr)?
dataType ::= 'String' ('('NUMBER')')? | 'Integer' | 'DateTime' | STRING (annotation ':' STRING)?

private required_ ::= not null

service_ ::= service literal_expr annotation? '{' ( service_entity | function_ | service_type)+ '}'
private service_type ::= type STRING '{' (STRING ':' many? dataType';')* '};'
private service_entity ::= annotation? entity literal_expr mirror? join_* exclude_? ( as_ | actions_ | ';')?
private exclude_ ::= excluding '{' literal_expr '}'
private mirror ::= as (projection on | select from) identifier
private join_ ::= join_type identifier (as STRING)? on expr (and expr)? ('{' join_expr (','join_expr)* ('} 'join_condition | '};'))?
private join_type ::= join | "left join" | "left outer join"
private join_condition ::= where expr
private join_expr ::= key? (identifier as STRING | case_)
private case_ ::= case when identifier is required_ then "'" STRING "'" else identifier end as string_concat ':' identifier
private as_ ::= '{' as_recursive '}'
private as_recursive ::=  identifier as literal_expr (',' as_recursive)*

private actions_ ::= actions '{' (action_ | function_)* '};'
private function_ ::= function method_call returns literal_expr ';'
private action_ ::= action method_call returns literal_expr ';'
private method_call ::= STRING'('(literal_expr ':' identifier)? ')'

annotation ::= '@' (readonly | "cds.on.insert" | annotation_restrict | annotation_requires | annotation_assert*)
private annotation_requires ::= '(' requires ':' hyphen_string ')'
private annotation_assert ::= "assert.unique" ':' '{' string_concat':' '[' STRING (','STRING)* ']''}'
private annotation_restrict ::= restrict ':' '['  annotation_statement ']'
private annotation_statement ::= '{' annotation_grant annotation_to? annotation_where? '}'
private annotation_grant ::= grant ':' '[' "'" crud_op "'" (',' hyphen_string)* ']' ','?
private annotation_to ::= to ':' hyphen_string ','?
private annotation_where ::= where ':' "'" expr (concat_key exists '(' sql_Statement ')' )? "'"
private sql_Statement ::= "select" literal_expr from identifier where expr (concat_key expr)
private concat_key ::= and | or
private crud_op ::= READ | UPDATE | DELETE

private expr ::= identifier '=' (identifier | variable | value_)
private variable ::= " $"identifier
private value_ ::= "'" STRING "'"

private literal_expr ::= (STRING | number)+

private string_concat ::= STRING ('-'|'_'STRING)*

hyphen_string ::= "'" '@'? STRING ((('-'|'_') | ('/' ('.'|'..')?)*)? STRING)* "'"
identifier ::= STRING
private path ::= STRING (('.' | '/') STRING)*