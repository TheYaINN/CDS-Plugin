{
  parserClass="de.joachimsohn.language.parser.CDSParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CDS"
  psiImplClassSuffix="Impl"
  psiPackage="de.joachimsohn.language.psi"
  psiImplPackage="de.joachimsohn.language.psi.impl"

  elementTypeHolderClass="de.joachimsohn.language.psi.CDSTypes"
  elementTypeClass="de.joachimsohn.language.psi.CDSElementType"
  tokenTypeClass="de.joachimsohn.language.psi.CDSTokenType"

  tokens = [
    //https://github.com/JetBrains/intellij-community/blob/master/plugins/groovy/groovy-psi/src/org/jetbrains/plugins/groovy/lang/parser/groovy.bnf

    LINE_COMMENT = 'regexp://.+'
    BLOCK_COMMENT = 'regexp:/\*.*\*/'

    LITERAL_NUMBER = 'regexp:\d+(\.\d*)?'
    LITERAL_STRING = 'regexp:[a-zA-Z]+'
    R_DATE = 'regexp:[0-9]{2}\.[0-9]{2}\.[0-9]{4}'

    KW_ENUM = 'enum'
    KW_TRUE = 'true'
    KW_FALSE = 'false'

    T_LBRACE = '{'
    T_LPAREN = '('
    T_LBRACK = '['
    T_RBRACK = ']'
    T_RPAREN = ')'
    T_RBRACE = '}'
    T_DOLLAR = '$'
    T_AT = '@'
    T_SLASH = '/'
    T_BACKSLASH = '\'
    T_SEMI = ';'
    T_COLON = ':'
    T_COMMA = ','
    T_DOT = '.'
    T_RECURSIVE_DESCENT = '..'
    T_HYPH = "'"
    T_QOUTE = '"'
    T_ASSIGN = '='
    T_UNDER = '_'
    T_MINUS = '-'

    KW_NAMESPACE = 'namespace'
    KW_USING = 'using'
    KW_FROM = 'from'
    KW_DEFINE = 'define'
    KW_ENTITY = 'entity'
    KW_SERVICE = 'service'
    KW_TYPE = 'type'
    KW_KEY = 'key'
    KW_REQUIRED = 'not null'
    KW_REQUIRES = 'requires'
    KW_ASSOCIATION_TO = 'Association to'
    KW_COMPOSITION_OF = 'Composition of'
    KW_MANY = 'many'
    KW_ON = 'on'
    KW_AS = 'as'
    KW_DEFAULT = 'default'
    KW_TYPE_OF = 'type of'
    KW_FUNCTION = 'function'
    KW_PROJECTION = 'projection'
    KW_SELECT = 'select'
    KW_EXCLUDING = 'excluding'
    KW_ACTION = 'action'
    KW_ACTIONS = 'actions'
    KW_RETURNS = 'returns'
    KW_JOIN = 'join'
    KW_LEFT = 'left'
    KW_RIGHT = 'right'
    KW_OUTER = 'outer'
    KW_INNER = 'inner'
    KW_WHERE = 'where'
    KW_AND = 'and'
    KW_OR = 'or'
    KW_EXISTS = 'exists'
    KW_READ_ONLY = 'readonly'
    KW_CDS = 'cds'
    KW_INSERT = 'insert'
    KW_ASSERT = 'assert'
    KW_UNIQUE = 'unique'
    KW_INTEGRITY = 'integrity'
    KW_FORMAT = 'format'
    KW_RANGE = 'range'
    KW_NOT_NULL = 'notNull'
    UPDATE = 'update'
    KW_USER = 'user'
    KW_NOW = 'now'
    KW_RESTRICT = 'restrict'
    KW_GRANT = 'grant'
    KW_TO = 'to'
  ]
}
root ::= namespace_? import_* body_*
namespace_ ::= KW_NAMESPACE path_dot T_SEMI

import_ ::= KW_USING  ( import_multiple | import_identifier ) import_as? KW_FROM single_quoted_string T_SEMI
private import_as ::= KW_AS import_as_identifier
private import_as_identifier ::= identifier
private import_multiple ::= T_LBRACE import_multiple_item (T_COMMA import_multiple_item)* T_RBRACE
private import_multiple_item ::= import_identifier import_as?
private import_identifier ::= path_dot { extends = identifier }

private body_ ::= model_ | service_ | LINE_COMMENT | BLOCK_COMMENT

model_ ::= annotation_* KW_DEFINE? ( type_ | entity_ )

private type_ ::= KW_TYPE type_identifier ( T_COLON  ( dataType | relation_ ) | type_object ) T_SEMI
private type_identifier ::= identifier
private type_object ::= T_LBRACE type_field* T_RBRACE
private type_field ::= type_field_identifier T_COLON dataType T_SEMI
private type_field_identifier ::= identifier

private entity_ ::=  KW_ENTITY entity_identifier entity_extend? T_LBRACE entity_field+ T_RBRACE T_SEMI
private entity_extend ::= T_COLON entity_extend_identifier
private entity_extend_identifier ::= identifier
private entity_identifier ::= identifier
private entity_field ::= KW_KEY? entity_field_identifier T_COLON (dataType entity_default? | relation_ | entity_type_reference ) KW_REQUIRED? T_SEMI
private entity_default ::= KW_DEFAULT entity_default_value
private entity_default_value ::= LITERAL_NUMBER | single_quoted_string
private entity_type_reference ::= KW_TYPE_OF entity_type_reference_object_identifier
private entity_type_reference_object_identifier ::= LITERAL_STRING (T_COLON LITERAL_STRING)? { extends = identifier }
private entity_field_identifier ::= identifier

service_ ::= KW_SERVICE service_identifier service_body T_SEMI
private service_identifier ::= identifier
private service_body ::= T_LBRACE ( service_entity |  service_type | method_ | actions_ )+ T_RBRACE
private service_entity ::= KW_ENTITY service_entity_identifier method_parameters? service_entity_mirror (join_body | join_ | sql_where_clause )? (actions_ | T_SEMI)?
private service_entity_identifier ::= identifier
private service_entity_mirror ::= KW_AS (KW_PROJECTION KW_ON | KW_SELECT KW_FROM) service_entity_mirror_identifier (T_LPAREN service_entity_mirror_params T_RPAREN)?
private service_entity_mirror_params ::= service_entity_mirror_params_identifier service_entity_mirror_params_value (T_COMMA service_entity_mirror_params_identifier service_entity_mirror_params_value)*
private service_entity_mirror_params_value ::= T_COLON identifier
private service_entity_mirror_params_identifier ::= identifier T_COLON
private service_entity_mirror_identifier ::= path_dot
private service_type ::= KW_TYPE service_type_identifier T_LBRACE service_type_field+ T_RBRACE T_SEMI
private service_type_field ::= service_type_field_identifier T_COLON KW_MANY? dataType T_SEMI
private service_type_field_identifier ::= identifier
private service_type_identifier ::= identifier

private actions_ ::= KW_ACTIONS T_LBRACE (method_ )* T_RBRACE T_SEMI
private method_ ::= ( KW_ACTION | KW_FUNCTION ) method_identifier method_parameters method_return? T_SEMI
private method_return ::= KW_RETURNS dataType
private method_parameters ::= T_LPAREN (method_parameters_value (T_COMMA method_parameters_value)*)? T_RPAREN
method_identifier ::= identifier
private method_parameters_value ::= identifier T_COLON identifier

private join_ ::= join_type identifier KW_ON expression join_body? join_condition
private join_type ::=  (KW_LEFT | KW_RIGHT)? (KW_OUTER | KW_INNER)? KW_JOIN
private join_body ::= T_LBRACE join_field  (T_COMMA join_field)* T_RBRACE
private join_field ::= path_dot ( KW_AS identifier)?
private join_condition ::= KW_WHERE expression

annotation_ ::= annotation_entry*
annotation_entry ::= T_AT (KW_READ_ONLY | annotation_cds | annotation_restrict | annotation_requires | annotation_assert)
private annotation_cds ::= KW_CDS T_DOT KW_ON T_DOT (KW_INSERT | KW_UPDATE) T_COLON T_DOLLAR (KW_NOW | KW_USER)
private annotation_requires ::= T_LPAREN KW_REQUIRED T_COLON single_quoted_string T_RPAREN
private annotation_assert ::= KW_ASSERT T_DOT (annotation_assert_unique | annotation_assert_integrity | annotation_assert_format | annotation_assert_range | annotation_assert_notnull)
private annotation_assert_unique ::= KW_UNIQUE T_COLON T_LBRACE annotation_assert_unique_field (T_COMMA annotation_assert_unique_field)* T_RBRACE
private annotation_assert_unique_field ::= entity_field_identifier T_COLON T_LBRACK identifier (T_COMMA identifier)* T_RBRACK
private annotation_assert_integrity ::= KW_INTEGRITY T_COLON dataType_boolean
private annotation_assert_format ::= KW_FORMAT T_COLON single_quoted_string T_COLON
private annotation_assert_range ::= KW_RANGE T_COLON (T_LBRACK ( dataType_numeric | R_DATE ) T_RBRACK | dataType_enum) T_COLON
private annotation_assert_notnull ::= KW_NOT_NULL T_COLON dataType_boolean
//TODO: refactor
private annotation_restrict ::= KW_RESTRICT  T_COLON T_LBRACK annotation_statement T_RBRACK
private annotation_statement ::= T_LBRACK annotation_grant annotation_to? annotation_where? T_RBRACE
private annotation_grant ::= KW_GRANT T_COLON T_LBRACK T_HYPH annotation_grant_authorization T_HYPH (T_COMMA single_quoted_string)* T_RBRACK T_COMMA?
private annotation_to ::= KW_TO T_COLON single_quoted_string T_COMMA?
private annotation_where ::= KW_WHERE T_COLON T_HYPH expression ( KW_EXISTS T_LPAREN sql_Statement T_RPAREN )? T_HYPH
private annotation_grant_authorization ::= READ | KW_UPDATE | DELETE
//TODO: refactor end

private sql_Statement ::= sql_select_clause sql_from_clause sql_where_clause
private sql_select_clause ::= KW_SELECT sql_select_clause_identifier (KW_AS sql_select_clause_identifier)?
private sql_select_clause_identifier ::= identifier
private sql_from_clause ::= KW_FROM sql_from_clause_identifier (KW_AS sql_from_clause_identifier)?
private sql_from_clause_identifier ::= identifier
private sql_where_clause ::= KW_WHERE expression ((KW_AND | KW_OR) expression)*

private expression ::= (expression_key T_ASSIGN expression_value) | expression_exists
private expression_key ::= path_dot
private expression_value ::= string_under | ( T_DOLLAR | T_COLON )? path_dot
private expression_exists ::= KW_EXISTS T_LPAREN sql_Statement T_RPAREN

identifier ::= (string_under | LITERAL_STRING | LITERAL_NUMBER )+

private string_encapsulation ::= T_HYPH | T_QOUTE
single_quoted_string ::= string_encapsulation ( path_slash |  LITERAL_STRING ) string_encapsulation
private string_under ::= LITERAL_STRING (T_UNDER LITERAL_STRING)+
private path_dot ::= LITERAL_STRING (T_DOT LITERAL_STRING)*
private path_slash ::= T_AT? file_path_element (T_SLASH file_path_element)*
private file_path_element ::= ( file_path_relative | LITERAL_STRING )
private file_path_relative ::= ( T_DOT | T_RECURSIVE_DESCENT )

dataType ::= 'String' '('LITERAL_NUMBER')' | dataType_enum
            | 'Integer'
            | 'Decimal'('('LITERAL_NUMBER','LITERAL_NUMBER')')?
            | 'DateTime'
            | 'Currency'
            | 'array of' ( entity_identifier | type_identifier )
            | entity_identifier
            | type_identifier

private dataType_enum ::= KW_ENUM T_LBRACE (identifier T_SEMI)+ T_RBRACE
private dataType_boolean ::= KW_TRUE | KW_FALSE
private dataType_numeric ::= LITERAL_NUMBER (T_DOT LITERAL_NUMBER)? //TODO: move to LITERAL_NUMBER to include .

private relation_ ::= (KW_ASSOCIATION_TO | KW_COMPOSITION_OF) KW_MANY? (relation_single | relation_body)
private relation_single ::= relation_identifier KW_REQUIRED? (KW_ON expression)?
private relation_identifier ::= path_dot { extends = identifier }
private relation_body ::= T_LBRACE relation_field+ T_RBRACE
private relation_field ::= KW_KEY? relation_field_identifier T_COLON ( dataType | relation_ ) T_SEMI
private relation_field_identifier ::= identifier
