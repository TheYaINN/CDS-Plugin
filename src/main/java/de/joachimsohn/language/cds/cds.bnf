{
  parserClass="de.joachimsohn.language.parser.CDSParser"
  //parserUtilClass="de.joachimsohn.language.parser.CDSParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CDS"
  psiImplClassSuffix="Impl"
  psiPackage="de.joachimsohn.language.psi"
  psiImplPackage="de.joachimsohn.language.psi.impl"

  elementTypeHolderClass="de.joachimsohn.language.psi.CDSTypes"
  elementTypeClass="de.joachimsohn.language.psi.CDSElementType"
  tokenTypeClass="de.joachimsohn.language.psi.CDSTokenType"

  tokens = [
        SPACE = 'regexp:\s+'
        number = 'regexp:\d+(\.\d*)?'
        string = 'regexp:[a-zA-Z]+'
  ]
}
CDSFile ::= namespace_? import_* type_declaration* item_*

namespace_ ::= namespace identifier';'

import_ ::= using (import_values | identifier import_as) from "'" path "';"
import_as ::= as string
import_values ::= '{' string (','string)* '}'

type_declaration ::= "type" string ':' type_
type_ ::= ('String' | 'Integer') enum '{' (string';')* '};'

item_ ::= ( service_ | data_entity | COMMENT | CRLF)
data_entity ::= annotation* entity string (':' string)? '{' field_* '}'
field_ ::= key? string ':' (dataType | association_ | composition_) required_? ';'
association_ ::= "Association to" many? string required_?(on expr)?
composition_ ::= "Composition of" many? string on expr
dataType ::= 'String' ('('number')')? | 'Integer' | 'DateTime' | string (annotation ':' string)?

required_ ::= not? null

service_ ::= service literal_expr annotation? '{' ( service_entity | function_ | service_type)+ '}'

service_type ::= type string '{' (string ':' many? dataType';')* '};'

service_entity ::= annotation? entity literal_expr mirror? join_* exclude_? ( as_ | actions_ | ';')?
exclude_ ::= excluding '{' literal_expr '}'
mirror ::= as (projection on | select from) identifier
join_ ::= join_type identifier (as string)? on expr (and expr)? ('{' join_expr (','join_expr)* ('} 'join_condition | '};'))?
join_type ::= join | "left join" | "left outer join"
join_condition ::= where expr
join_expr ::= key? (identifier as string | case_)
case_ ::= case when identifier is required_ then "'" string "'" else identifier end as string_concat ':' identifier
as_ ::= '{' as_recursive '}'
as_recursive ::=  identifier as literal_expr (',' as_recursive)*

actions_ ::= actions '{' (action_ | function_)* '};'
function_ ::= function method_call returns literal_expr ';'
action_ ::= action method_call returns literal_expr ';'
method_call ::= string'('(literal_expr ':' identifier)? ')'

annotation ::= '@' (readonly | "cds.on.insert" | annotation_restrict | annotation_requires | annotation_assert*)

annotation_requires ::= '(' requires ':' hyphen_string ')'
annotation_assert ::= assert'.'unique ':' '{' string_concat':' '[' string (','string)* ']''}'
annotation_restrict ::= restrict ':' '['  annotation_statement ']'
annotation_statement ::= '{' annotation_grant annotation_to? annotation_where? '}'
annotation_grant ::= grant ':' '[' "'" crud_op "'" (',' hyphen_string)* ']' ','?
annotation_to ::= to ':' hyphen_string ','?
annotation_where ::= where ':' "'" expr (concat_key exists '(' sql_Statement ')' )? "'"
sql_Statement ::= "select" literal_expr from identifier where expr (concat_key expr)
concat_key ::= and | or

expr ::= identifier '=' (identifier | variable | value_)
variable ::= "$"identifier
value_ ::= "'" string "'"

literal_expr ::= (string | number)+
identifier ::=(string+ '.'?)+

string_concat ::= string (('-'|'_')?string)*
hyphen_string ::= "'" string_concat "'"

path ::= (('@' string | '.' | '..' | string_concat | string)('/' | '.')?)*
crud_op ::= READ | UPDATE | DELETE
