{
  parserClass="de.joachimsohn.language.parser.CDSParser"
  //parserUtilClass="de.joachimsohn.language.parser.CDSParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CDS"
  psiImplClassSuffix="Impl"
  psiPackage="de.joachimsohn.language.psi"
  psiImplPackage="de.joachimsohn.language.psi.impl"

  elementTypeHolderClass="de.joachimsohn.language.psi.CDSTypes"
  elementTypeClass="de.joachimsohn.language.psi.CDSElementType"
  tokenTypeClass="de.joachimsohn.language.psi.CDSTokenType"

  tokens = [
        LINE_COMMENT = 'regexp://'
        BLOCK_COMMENT = 'regexp:/\*.*\*/'
        SPACE = 'regexp:\s+'
        number = 'regexp:\d+(\.\d*)?'
        string = 'regexp:[a-zA-Z]+'
  ]
}
CDSFile ::= namespace_? import_* type_declaration* item_*

namespace_ ::= namespace identifier';'

import_ ::= using'{'import_values'}' 'from' hyphen_string';'
private import_values ::= string (',' string)*


type_declaration ::= "type" string ':' type_
private type_ ::= dataType enum '{' (string';')* '};'

item_ ::= ( service_ | entity_ | COMMENT | CRLF)
private entity_ ::= annotation* "define"? "entity" string (':' string)? '{' field_* '}'
private field_ ::= key? string ':' (dataType | relation_ | association_ | composition_) required_? ';'
private relation_ ::= (Association to | Composition of ) many? string required_? (on expr)?
dataType ::= 'String' ('('number')')? | 'Integer' | 'DateTime' | string (annotation ':' string)?

required_ ::= not? null

service_ ::= service literal_expr annotation? '{' ( service_entity | function_ | service_type)+ '}'
private service_type ::= type string '{' (string ':' many? dataType';')* '};'
private service_entity ::= annotation? entity literal_expr mirror? join_* exclude_? ( as_ | actions_ | ';')?
private exclude_ ::= excluding '{' literal_expr '}'
private mirror ::= as (projection on | select from) identifier
private join_ ::= join_type identifier (as string)? on expr (and expr)? ('{' join_expr (','join_expr)* ('} 'join_condition | '};'))?
private join_type ::= join | "left join" | "left outer join"
private join_condition ::= where expr
private join_expr ::= key? (identifier as string | case_)
private case_ ::= case when identifier is required_ then "'" string "'" else identifier end as string_concat ':' identifier
private as_ ::= '{' as_recursive '}'
private as_recursive ::=  identifier as literal_expr (',' as_recursive)*

actions_ ::= actions '{' (action_ | function_)* '};'
function_ ::= function method_call returns literal_expr ';'
private action_ ::= action method_call returns literal_expr ';'
method_call ::= string'('(literal_expr ':' identifier)? ')'

annotation ::= '@' (readonly | "cds.on.insert" | annotation_restrict | annotation_requires | annotation_assert*)
private annotation_requires ::= '(' requires ':' hyphen_string ')'
private annotation_assert ::= "assert.unique" ':' '{' string_concat':' '[' string (','string)* ']''}'
private annotation_restrict ::= restrict ':' '['  annotation_statement ']'
private annotation_statement ::= '{' annotation_grant annotation_to? annotation_where? '}'
private annotation_grant ::= grant ':' '[' "'" crud_op "'" (',' hyphen_string)* ']' ','?
private annotation_to ::= to ':' hyphen_string ','?
private annotation_where ::= where ':' "'" expr (concat_key exists '(' sql_Statement ')' )? "'"
private sql_Statement ::= "select" literal_expr from identifier where expr (concat_key expr)
private concat_key ::= and | or
private crud_op ::= READ | UPDATE | DELETE

expr ::= identifier '=' (identifier | variable | value_)
private variable ::= " $"identifier
private value_ ::= "'" string "'"

literal_expr ::= (string | number)+
identifier ::= (string+ '.'?)+

string_concat ::= string ('-'|'_'string)*
hyphen_string ::= "'"(string_concat | path)"'"

private path ::= (('@' string | '.' | '..' | string_concat | string)('/' | '.')?)*