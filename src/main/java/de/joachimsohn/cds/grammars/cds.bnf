{
  parserClass="de.joachimsohn.cds.parser.CDSParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CDS"
  psiImplClassSuffix="Impl"
  psiPackage="de.joachimsohn.cds.psi"
  psiImplPackage="de.joachimsohn.cds.psi.impl"

  elementTypeHolderClass="de.joachimsohn.cds.psi.CDSTypes"
  elementTypeClass="de.joachimsohn.cds.lang.CDSElementType"
  tokenTypeClass="de.joachimsohn.cds.lang.CDSTokenType"

  tokens = [
    LINE_COMMENT = 'regexp://.+'
    BLOCK_COMMENT = 'regexp:/\*.*\*/'

    stringlit = "regexp:'[\w\.(\.\.)\-/@]+'"
    numberlit = 'regexp:\d+(\.\d*)?'
    B_TRUE = 'true'
    B_FALSE = 'false'
    id = 'regexp:\w+'

    KW_ENUM = 'enum'

    T_LBRACE = '{'
    T_LPAREN = '('
    T_LBRACK = '['
    T_RBRACK = ']'
    T_RPAREN = ')'
    T_RBRACE = '}'
    T_DOLLAR = '$'
    T_AT = '@'
    T_SLASH = '/'
    T_BACKSLASH = '\'
    T_SEMI = ';'
    T_COLON = ':'
    T_COMMA = ','
    T_DOT = '.'
    T_RECURSIVE_DESCENT = '..'
    T_HYPH = "'"
    T_QOUTE = '"'
    T_ASSIGN = '='
    T_UNDER = '_'
    T_MINUS = '-'

    KW_NAMESPACE = 'namespace'
    KW_USING = 'using'
    KW_FROM = 'from'
    KW_DEFINE = 'define'
    KW_ENTITY = 'entity'
    KW_ASPECT = 'aspect'
    KW_SERVICE = 'service'
    KW_TYPE = 'type'
    KW_KEY = 'key'
    KW_REQUIRES = 'requires'
    KW_ASSOCIATION_TO = 'Association to'
    KW_COMPOSITION_OF = 'Composition of'
    KW_MANY = 'many'
    KW_ARRAY = 'array of'
    KW_ON = 'on'
    KW_AS = 'as'
    KW_DEFAULT = 'default'
    KW_TYPE_OF = 'type of'
    KW_FUNCTION = 'function'
    KW_PROJECTION = 'projection'
    KW_SELECT = 'select'
    KW_EXCLUDING = 'excluding'
    KW_ACTION = 'action'
    KW_ACTIONS = 'actions'
    KW_RETURNS = 'returns'
    KW_JOIN = 'join'
    KW_LEFT = 'left'
    KW_RIGHT = 'right'
    KW_OUTER = 'outer'
    KW_INNER = 'inner'
    KW_WHERE = 'where'
    KW_AND = 'and'
    KW_OR = 'or'
    KW_EXISTS = 'exists'
    KW_READ_ONLY = 'readonly'
    KW_CDS_ON = 'cds.on'
    KW_INSERT = 'insert'
    KW_ASSERT = 'assert'
    KW_UNIQUE = 'unique'
    KW_INTEGRITY = 'integrity'
    KW_FORMAT = 'format'
    KW_RANGE = 'range'
    KW_NOTNULL = 'notNull'
    KW_NOT_NULL = 'not null'
    UPDATE = 'update'
    KW_USER = 'user'
    KW_NOW = 'now'
    KW_RESTRICT = 'restrict'
    KW_GRANT = 'grant'
    KW_TO = 'to'
  ]
}
File ::= [Namespace] import_* RootItems
Namespace ::= KW_NAMESPACE PropertyPath T_SEMI

import_ ::= KW_USING  ( import_multiple | import_identifier )? KW_FROM literal_string T_SEMI
private import_as ::= KW_AS import_as_identifier
private import_as_identifier ::= identifier
private import_multiple ::= T_LBRACE import_multiple_item (T_COMMA import_multiple_item)* T_RBRACE
private import_multiple_item ::= import_identifier
private import_identifier ::= PropertyPath [import_as]

RootItems ::= annotation ( model_ | service_ )*

model_ ::= KW_DEFINE? ( type_ | entity_ | aspect_ )

private aspect_ ::= KW_ASPECT aspect_identifier T_LBRACE aspect_field+ T_RBRACE T_SEMI
private aspect_identifier ::= identifier
private aspect_field ::= aspect_identifier T_COLON Datatype T_SEMI

private type_ ::= KW_TYPE type_identifier ( T_COLON  ( Datatype | relation_ ) | type_object ) T_SEMI
private type_identifier ::= identifier
private type_object ::= T_LBRACE type_field* T_RBRACE
private type_field ::= type_field_identifier T_COLON Datatype T_SEMI
private type_field_identifier ::= identifier

private entity_ ::=  KW_ENTITY entity_identifier entity_extend? T_LBRACE entity_field+ T_RBRACE T_SEMI
private entity_extend ::= T_COLON entity_extend_identifier (T_COMMA entity_extend_identifier)*
private entity_extend_identifier ::= identifier
private entity_identifier ::= identifier
private entity_field ::= KW_KEY? entity_field_identifier T_COLON (Datatype [entity_default] | relation_ | entity_type_reference ) [KW_NOT_NULL] annotation T_SEMI
private entity_default ::= KW_DEFAULT entity_default_value
private entity_default_value ::= literal_number | stringlit
private entity_type_reference ::= KW_TYPE_OF entity_type_reference_object_identifier
private entity_type_reference_object_identifier ::= id [T_COLON id] { extends = identifier }
private entity_field_identifier ::= identifier

service_ ::= KW_SERVICE service_identifier service_body T_SEMI
private service_identifier ::= identifier
private service_body ::= T_LBRACE (( service_entity |  service_type | method_ | actions_ ) T_SEMI )+ T_RBRACE
private service_entity ::= KW_ENTITY service_entity_identifier method_parameters? (service_entity_body | service_entity_mirror) (join_body | join_ | sql_where_clause )? actions_?
private service_entity_body ::= T_LBRACE service_entity_field T_RBRACE
private service_entity_field ::= [KW_KEY] service_entity_field_identifier T_COLON Datatype
private service_entity_field_identifier ::= identifier
private service_entity_identifier ::= identifier
private service_entity_mirror ::= KW_AS (KW_PROJECTION KW_ON | KW_SELECT KW_FROM) service_entity_mirror_identifier (T_LPAREN service_entity_mirror_params T_RPAREN)?
private service_entity_mirror_params ::= service_entity_mirror_params_identifier service_entity_mirror_params_value (T_COMMA service_entity_mirror_params_identifier service_entity_mirror_params_value)*
private service_entity_mirror_params_value ::= T_COLON identifier
private service_entity_mirror_params_identifier ::= identifier T_COLON
private service_entity_mirror_identifier ::= PropertyPath
private service_type ::= KW_TYPE service_type_identifier T_LBRACE service_type_field+ T_RBRACE
private service_type_field ::= service_type_field_identifier T_COLON KW_MANY? Datatype T_SEMI
private service_type_field_identifier ::= identifier
private service_type_identifier ::= identifier

private actions_ ::= KW_ACTIONS T_LBRACE (method_ T_SEMI)* T_RBRACE
private method_ ::= ( KW_ACTION | KW_FUNCTION ) method_identifier method_parameters method_return?
private method_return ::= KW_RETURNS Datatype
private method_parameters ::= T_LPAREN (method_parameters_value (T_COMMA method_parameters_value)*)? T_RPAREN
private method_identifier ::= identifier
private method_parameters_value ::= identifier T_COLON identifier

private join_ ::= join_type identifier KW_ON expression [join_body] join_condition
private join_type ::=  (KW_LEFT | KW_RIGHT)? (KW_OUTER | KW_INNER)? KW_JOIN
private join_body ::= T_LBRACE join_field  (T_COMMA join_field)* T_RBRACE
private join_field ::= PropertyPath ( KW_AS identifier)?
private join_condition ::= KW_WHERE expression

annotation ::= annotation_entry*
private annotation_entry ::= T_AT (KW_READ_ONLY | annotation_cds | annotation_restrict | annotation_requires | annotation_assert)
private annotation_cds ::= KW_CDS_ON (KW_INSERT | KW_UPDATE) T_COLON T_DOLLAR (KW_NOW | KW_USER)
private annotation_requires ::= T_LPAREN KW_NOT_NULL T_COLON stringlit T_RPAREN
private annotation_assert ::= KW_ASSERT T_DOT (annotation_assert_unique | annotation_assert_integrity | annotation_assert_format | annotation_assert_range | annotation_assert_notnull)
private annotation_assert_unique ::= KW_UNIQUE T_COLON T_LBRACE annotation_assert_unique_field (T_COMMA annotation_assert_unique_field)* T_RBRACE
private annotation_assert_unique_field ::= entity_field_identifier T_COLON T_LBRACK identifier (T_COMMA identifier)* T_RBRACK
private annotation_assert_integrity ::= KW_INTEGRITY T_COLON literal_boolean
private annotation_assert_format ::= KW_FORMAT T_COLON stringlit T_COLON
private annotation_assert_range ::= KW_RANGE T_COLON (T_LBRACK ( literal_number | R_DATE ) T_RBRACK | Datatype_Enum) T_COLON
private annotation_assert_notnull ::= KW_NOTNULL T_COLON literal_boolean
private annotation_restrict ::= KW_RESTRICT  T_COLON T_LBRACK annotation_statement T_RBRACK
private annotation_statement ::= T_LBRACK annotation_grant annotation_to? annotation_where? T_RBRACE
private annotation_grant ::= KW_GRANT T_COLON T_LBRACK T_HYPH annotation_grant_authorization T_HYPH (T_COMMA stringlit)* T_RBRACK T_COMMA?
private annotation_to ::= KW_TO T_COLON stringlit T_COMMA?
private annotation_where ::= KW_WHERE T_COLON T_HYPH expression ( KW_EXISTS T_LPAREN sql_Statement T_RPAREN )? T_HYPH
private annotation_grant_authorization ::= READ | KW_UPDATE | DELETE

private sql_Statement ::= sql_select_clause sql_from_clause sql_where_clause
private sql_select_clause ::= KW_SELECT sql_select_clause_identifier (KW_AS sql_select_clause_identifier)?
private sql_select_clause_identifier ::= identifier
private sql_from_clause ::= KW_FROM sql_from_clause_identifier (KW_AS sql_from_clause_identifier)?
private sql_from_clause_identifier ::= identifier
private sql_where_clause ::= KW_WHERE expression ((KW_AND | KW_OR) expression)*

private expression ::= (expression_key T_ASSIGN expression_value) | expression_exists
private expression_key ::= PropertyPath
private expression_value ::= string_under | ( T_DOLLAR | T_COLON )? PropertyPath
private expression_exists ::= KW_EXISTS T_LPAREN sql_Statement T_RPAREN

identifier ::= id

private string_under ::= literal_string (T_UNDER literal_string)+
private PropertyPath ::= id (T_DOT id)*

private Datatype ::= Datatypes [Datatype_Enum] [KW_NOT_NULL] (KW_DEFAULT (literal_string | literal_number | literal_boolean))?

Datatypes ::= 'Boolean'
            | 'Integer'
            | 'Integer64'
            | 'Decimal' [Datatype_Argument_Decimal]
            | 'Double'
            | 'Date'
            | 'Time'
            | 'DateTime'
            | 'String' [Datatype_Argument]
            | 'Binary' [Datatype_Argument]
            | 'LargeBinary'
            | 'LargeString'

private Datatype_Argument ::= T_LPAREN literal_number T_RPAREN
private Datatype_Argument_Decimal ::= T_LPAREN literal_number T_COMMA literal_number T_RPAREN

private Datatype_Enum ::= KW_ENUM T_LBRACE (identifier (Datatype_Enum_assignment)? T_SEMI)+ T_RBRACE
private Datatype_Enum_assignment ::= T_ASSIGN (literal_string | literal_number | literal_boolean)

private relation_ ::= (KW_ASSOCIATION_TO | KW_COMPOSITION_OF) KW_MANY? (relation_single | relation_body)
private relation_single ::= relation_identifier KW_NOT_NULL? (KW_ON expression)?
private relation_identifier ::= PropertyPath { extends = identifier }
private relation_body ::= T_LBRACE relation_field+ T_RBRACE
private relation_field ::= KW_KEY? relation_field_identifier T_COLON ( Datatype | relation_ ) T_SEMI
private relation_field_identifier ::= identifier

private literal_string ::= stringlit
private literal_number ::= numberlit
private literal_boolean ::= B_FALSE | B_TRUE
