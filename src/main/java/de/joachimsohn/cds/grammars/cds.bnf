{
  parserClass="de.joachimsohn.cds.parser.CDSParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CDS"
  psiImplClassSuffix="Impl"
  psiPackage="de.joachimsohn.cds.psi"
  psiImplPackage="de.joachimsohn.cds.psi.impl"

  elementTypeHolderClass="de.joachimsohn.cds.psi.CDSTypes"
  elementTypeClass="de.joachimsohn.cds.lang.CDSElementType"
  tokenTypeClass="de.joachimsohn.cds.lang.CDSTokenType"

  tokens = [
    LINE_COMMENT = 'regexp://.+'
    BLOCK_COMMENT = 'regexp:/\*[\w\n]*\*/'

    stringlit = "regexp:'[\w\.(\.\.)\-/@]+'"
    numberlit = 'regexp:-?\d+(\.\d*)?'

    B_TRUE = 'true'
    B_FALSE = 'false'
    id = 'regexp:\w+'

    KW_ENUM = 'enum'

    T_LBRACE = '{'
    T_LPAREN = '('
    T_LBRACK = '['
    T_RBRACK = ']'
    T_RPAREN = ')'
    T_RBRACE = '}'
    T_DOLLAR = '$'
    T_AT = '@'
    T_SLASH = '/'
    T_BACKSLASH = '\'
    T_SEMI = ';'
    T_COLON = ':'
    T_COMMA = ','
    T_DOT = '.'
    T_RECURSIVE_DESCENT = '..'
    T_HYPH = "'"
    T_QOUTE = '"'
    T_ASSIGN = '='
    T_UNDER = '_'
    T_MINUS = '-'
    T_MUL = '*'


    //reserved words
    KW_NAMESPACE = 'namespace'
    KW_USING = 'using'
    KW_FROM = 'from'
    KW_DEFINE = 'define'
    KW_ENTITY = 'entity'
    KW_ASPECT = 'aspect'
    KW_SERVICE = 'service'
    KW_TYPE = 'type'
    KW_KEY = 'key'

    KW_VIRTUAL = 'virtual'
    KW_REQUIRES = 'requires'
    KW_ASSOCIATION_TO = 'Association to'
    KW_COMPOSITION_OF = 'Composition of'
    KW_MANY = 'many'
    KW_ARRAY = 'array of'
    KW_ON = 'on'
    KW_AS = 'as'
    KW_DEFAULT = 'default'
    KW_TYPE_OF = 'type of'
    KW_FUNCTION = 'function'
    KW_PROJECTION = 'projection'
    KW_SELECT = 'select'
    KW_EXCLUDING = 'excluding'
    KW_ACTION = 'action'
    KW_ACTIONS = 'actions'
    KW_RETURNS = 'returns'
    KW_JOIN = 'join'
    KW_LEFT = 'left'
    KW_RIGHT = 'right'
    KW_OUTER = 'outer'
    KW_INNER = 'inner'
    KW_WHERE = 'where'
    KW_AND = 'and'
    KW_OR = 'or'
    KW_EXISTS = 'exists'
    KW_INSERT = 'insert'
    KW_INTEGRITY = 'integrity'
    KW_FORMAT = 'format'
    KW_RANGE = 'range'
    KW_NOTNULL = 'notNull'
    KW_NOT_NULL = 'not null'
    UPDATE = 'update'
    KW_USER = 'user'
    KW_NOW = 'now'

    //SQL
    KW_GROUP_BY = 'group by'
    KW_ORDER_BY = 'order by'
    KW_ASC = 'asc'
    KW_DESC = 'desc'

    //annotations
    KW_RESTRICT = 'restrict'
    KW_GRANT = 'grant'
    KW_TO = 'to'
    KW_ASSERT = 'assert'
    KW_UNIQUE = 'unique'
    KW_CDS_ON = 'cds.on'
    ANNOT_READ_ONLY = 'readonly'
    ANNOT_MANDATORY = 'mandatory'
    ANNOT_CORE_MEDIATYPE = 'Core.MediaType'
    ANNOT_FIORI_DRAFT_ENABLED = 'fiori.draft.enabled'
    ANNOT_ODATA_DRAFT_ENABLED = 'odata.draft.enabled'
  ]
}
File ::= [Namespace] Import* RootItems*
Namespace ::= KW_NAMESPACE PropertyPath T_SEMI

Import ::= KW_USING  ( ImportMultiple | ImportIdentifier )? KW_FROM literal_string T_SEMI
private ImportAs ::= KW_AS ImportAsIdentifier
private ImportAsIdentifier ::= identifier
private ImportMultiple ::= T_LBRACE ImportMultipleItem (T_COMMA ImportMultipleItem)* T_RBRACE
private ImportMultipleItem ::= ImportIdentifier
private ImportIdentifier ::= PropertyPath [ImportAs]

RootItems ::= Annotation ( Model | Service )

Model ::= [KW_DEFINE] ( Type | Entity | Aspect )

private Aspect ::= KW_ASPECT AspectIdentifier T_LBRACE AspectField+ T_RBRACE T_SEMI
private AspectIdentifier ::= identifier
private AspectField ::= [Annotation] AspectIdentifier T_COLON Datatype T_SEMI

private Type ::= KW_TYPE TypeIdentifier ( T_COLON  ( Datatype | Relation ) | TypeObject ) T_SEMI
private TypeIdentifier ::= identifier
private TypeObject ::= T_LBRACE TypeField* T_RBRACE
private TypeField ::= TypeFieldIdentifier T_COLON Datatype T_SEMI
private TypeFieldIdentifier ::= identifier

private Entity ::=  KW_ENTITY EntityIdentifier [EntityExtend] ( EntityBody | EntityMirror ) [Join] [Actions] T_SEMI
private EntityIdentifier ::= identifier
private EntityExtend ::= T_COLON EntityIdentifier (T_COMMA EntityIdentifier)*
private EntityBody ::= T_LBRACE EntityField+ T_RBRACE
private EntityField ::= [Annotation] [EntityFieldModifier] EntityFieldIdentifier T_COLON (Datatype | Relation | EntityTypeReference | EntityBody ) Annotation T_SEMI
private EntityFieldModifier ::= KW_KEY | KW_VIRTUAL
private EntityFieldIdentifier ::= identifier
private EntityMirror ::= KW_AS (KW_PROJECTION KW_ON | KW_SELECT KW_FROM) EntityMirrorIdentifier [EntityMirrorSpecifier]
private EntityMirrorIdentifier ::= identifier
private EntityMirrorSpecifier ::= T_LBRACE EntityMirrorSpecifierParameter T_RBRACE
private EntityMirrorSpecifierParameter ::= identifier | T_MUL
private EntityTypeReference ::= KW_TYPE_OF EntityTypeReferenceObjectIdentifier
private EntityTypeReferenceObjectIdentifier ::= id [T_COLON id] { extends = identifier }

private Join ::= JoinType EntityIdentifier KW_ON Expression [JoinBody] [SQLWhere] [SQLGroupBy] [SQLOrderBy]
private JoinType ::= ( KW_LEFT | KW_RIGHT )? ( KW_OUTER | KW_INNER )? KW_JOIN
private JoinBody ::= T_LBRACE JoinField (T_COMMA JoinField)* T_RBRACE
private JoinField ::= PropertyPath (KW_AS identifier)?

Service ::= KW_SERVICE ServiceIdentifier ServiceBody T_SEMI
private ServiceIdentifier ::= identifier
private ServiceBody ::= T_LBRACE (( Entity |  ServiceType | Method | Actions ) T_SEMI )+ T_RBRACE
private ServiceType ::= KW_TYPE service_type_identifier T_LBRACE ServiceTypeField+ T_RBRACE
private ServiceTypeField ::= service_type_field_identifier T_COLON KW_MANY? Datatype T_SEMI
private service_type_field_identifier ::= identifier
private service_type_identifier ::= identifier

private Actions ::= KW_ACTIONS T_LBRACE (Method T_SEMI)* T_RBRACE
private Method ::= ( KW_ACTION | KW_FUNCTION ) MethodIdentifier MethodParams MethodReturn?
private MethodReturn ::= KW_RETURNS Datatype
private MethodParams ::= T_LPAREN (MethodParamsValue (T_COMMA MethodParamsValue)*)? T_RPAREN
private MethodIdentifier ::= identifier
private MethodParamsValue ::= identifier T_COLON identifier

Annotation ::= AnnotationEntry*
private AnnotationEntry ::= T_AT ( ANNOT_READ_ONLY | annotation_cds | annotation_restrict | annotation_requires | annotation_assert | AnnotationMediaType | ANNOT_FIORI_DRAFT_ENABLED | )
private AnnotationMediaType ::= ANNOT_CORE_MEDIATYPE T_COLON literal_string
private annotation_cds ::= KW_CDS_ON ( KW_INSERT | KW_UPDATE ) T_COLON T_DOLLAR (KW_NOW | KW_USER)
private annotation_requires ::= T_LPAREN KW_NOT_NULL T_COLON stringlit T_RPAREN
private annotation_assert ::= KW_ASSERT T_DOT (annotation_assert_unique | annotation_assert_integrity | annotation_assert_format | annotation_assert_range | annotation_assert_notnull)
private annotation_assert_unique ::= KW_UNIQUE T_COLON T_LBRACE annotation_assert_unique_field (T_COMMA annotation_assert_unique_field)* T_RBRACE
private annotation_assert_unique_field ::= EntityFieldIdentifier T_COLON T_LBRACK identifier (T_COMMA identifier)* T_RBRACK
private annotation_assert_integrity ::= KW_INTEGRITY T_COLON literal_boolean
private annotation_assert_format ::= KW_FORMAT T_COLON stringlit T_COLON
private annotation_assert_range ::= KW_RANGE T_COLON (T_LBRACK ( literal_number | R_DATE ) T_RBRACK | Datatype_Enum) T_COLON
private annotation_assert_notnull ::= KW_NOTNULL T_COLON literal_boolean
private annotation_restrict ::= KW_RESTRICT  T_COLON T_LBRACK annotation_statement T_RBRACK
private annotation_statement ::= T_LBRACK annotation_grant annotation_to? annotation_where? T_RBRACE
private annotation_grant ::= KW_GRANT T_COLON T_LBRACK T_HYPH annotation_grant_authorization T_HYPH (T_COMMA stringlit)* T_RBRACK T_COMMA?
private annotation_to ::= KW_TO T_COLON stringlit T_COMMA?
private annotation_where ::= KW_WHERE T_COLON T_HYPH Expression ( KW_EXISTS T_LPAREN SQL T_RPAREN )? T_HYPH
private annotation_grant_authorization ::= READ | KW_UPDATE | DELETE

SQL ::= SQLSelect SQLFrom [SQLWhere] [SQLGroupBy] [SQLOrderBy]
private SQLSelect ::= KW_SELECT SQLSelectIdentifier (KW_AS SQLSelectIdentifier)?
private SQLSelectIdentifier ::= identifier
private SQLFrom ::= KW_FROM SQLFromIdentifier (KW_AS SQLFromIdentifier)?
private SQLFromIdentifier ::= identifier
SQLWhere ::= KW_WHERE ((KW_EXISTS T_LPAREN SQL T_RPAREN) | (Expression ((KW_AND | KW_OR) Expression)*))
SQLGroupBy ::= KW_GROUP_BY identifier (T_COMMA identifier)*
SQLOrderBy ::= KW_ORDER_BY identifier ( KW_ASC | KW_DESC )?

private Expression ::= ExpressionKey (T_ASSIGN ExpressionValue)?
private ExpressionKey ::= PropertyPath
private ExpressionValue ::= [T_DOLLAR] PropertyPath

identifier ::= id

private PropertyPath ::= id (T_DOT id)*

private Relation ::= (KW_ASSOCIATION_TO | KW_COMPOSITION_OF) KW_MANY? (relation_single | relation_body)
private relation_single ::= relation_identifier KW_NOT_NULL? (KW_ON Expression)?
private relation_identifier ::= PropertyPath { extends = identifier }
private relation_body ::= T_LBRACE relation_field+ T_RBRACE
private relation_field ::= KW_KEY? relation_field_identifier T_COLON ( Datatype | Relation ) T_SEMI
private relation_field_identifier ::= identifier

private Datatype ::= Datatypes [Annotation] [Datatype_Enum] [KW_NOT_NULL] (KW_DEFAULT (literal_string | literal_number | literal_boolean))?
Datatypes ::= 'Boolean'
            | 'Integer'
            | 'Integer64'
            | 'Decimal' [Datatype_Argument_Decimal]
            | 'Double'
            | 'Date'
            | 'Time'
            | 'DateTime'
            | 'String' [Datatype_Argument]
            | 'Binary' [Datatype_Argument]
            | 'LargeBinary'
            | 'LargeString'

private Datatype_Argument ::= T_LPAREN literal_number T_RPAREN
private Datatype_Argument_Decimal ::= T_LPAREN literal_number T_COMMA literal_number T_RPAREN

private Datatype_Enum ::= KW_ENUM T_LBRACE (identifier (Datatype_Enum_assignment)? T_SEMI)+ T_RBRACE
private Datatype_Enum_assignment ::= T_ASSIGN (literal_string | literal_number | literal_boolean)

private literal_string ::= stringlit
private literal_number ::= numberlit
private literal_boolean ::= B_FALSE | B_TRUE